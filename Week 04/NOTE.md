字典树
通过树形节点记录每个字符，并在叶子节点上定义特殊的symbol来记录该单词的出现次数
这种数据结构在取出现最大次数的字符串时比较方便

kmp算法 
前提条件是pattern中存在重复字串（必须是从0开始重复，因为涉及到全匹配）
通过记录跳表中已存在重复的个数
在与source匹配过程中，如遇到不匹配回跳到之前重复字串之后，避免从头开始重新匹配，提升匹配效率
因此关键在于跳表的设计


wildcard
首先匹配pattern中第一个*之前的字符；
中间*隔开的子pattern，通过正则进行匹配，其中RegExp的lastIndex很重要，可以设置源字符串从哪里开始匹配，当正则是global匹配时，每次执行exec后lastIndex会变成最新一次匹配后的index，如果没匹配到则返回null，并将lastIndex自动设置为0；
最后是匹配最后一个*之后的字符，和第一个*之前的匹配规则一致
？老师提到的optional作业，用带？的kmp替换正则是什么意思？我没get到
